module.exports = TypeMap;

/**
 * Slow but simple way of creating a map where the key is an object. Works in
 * O(n) time util real maps appear in es6, so its fine for a small amount of
 * entries.
 * @constructor
 */
function TypeMap()
{
  if (!(this instanceof TypeMap))
    return new TypeMap();

  this._entries = [];
}

/**
 * @constructor
 */
function Entry(T, thing)
{
  this.T     = T;
  this.thing = thing;
}

/**
 * @param {Function} T
 * @param {any} d Default value.
 */
TypeMap.prototype.get = function(T, d)
{
  var entry = find(this._entries, function(x) { return x.T === T; });

  if (!entry && d !== undefined) {
    this.set(T, d);
    return d;
  }

  return entry ? entry.thing : null;
};

/**
 * @param {Function} T
 * @param {any} thing
 */
TypeMap.prototype.set = function(T, thing)
{
  var entry = find(this._entries, function(x) { return x.T === T; });
  if (entry) {
    entry.thing = thing;
  } else {
    this._entries.push(new Entry(T, thing));
  }
};

/**
 * Iterate over all entries
 * @param {function(item:any, key:object)} f
 */
TypeMap.prototype.each = function(f)
{
  for (var n = 0; n < this._entries.length; n++) {
    var entry = this._entries[n];
    f(entry.thing, entry.T);
  }
};

/**
 * Underscore-style find method
 * @param {array.<any>} haystack
 * @param {function(item:any): boolean} predicate
 * @return {any}
 */
function find(haystack, predicate)
{
  for (var n = 0; n < haystack.length; n++) {
    var item = haystack[n];
    if (predicate(item))
      return item;
  }

  return null;
}

